<!DOCTYPE html>
<html lang="es" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ESO/BESO | Kssgarcia</title>
<meta name="keywords" content="">
<meta name="description" content="El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.
El método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.
Optimizacion por nivel de esfuerzo Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo">
<meta name="author" content="">
<link rel="canonical" href="http://kssgarcia.github.io/es/posts/eso_beso/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://kssgarcia.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://kssgarcia.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://kssgarcia.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://kssgarcia.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://kssgarcia.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://kssgarcia.github.io/posts/eso_beso/">
<link rel="alternate" hreflang="es" href="http://kssgarcia.github.io/es/posts/eso_beso/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="ESO/BESO" />
<meta property="og:description" content="El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.
El método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.
Optimizacion por nivel de esfuerzo Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://kssgarcia.github.io/es/posts/eso_beso/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T11:48:52-05:00" />
<meta property="article:modified_time" content="2023-03-15T11:48:52-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ESO/BESO"/>
<meta name="twitter:description" content="El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.
El método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.
Optimizacion por nivel de esfuerzo Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://kssgarcia.github.io/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ESO/BESO",
      "item": "http://kssgarcia.github.io/es/posts/eso_beso/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ESO/BESO",
  "name": "ESO\/BESO",
  "description": "El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.\nEl método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.\nOptimizacion por nivel de esfuerzo Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo",
  "keywords": [
    
  ],
  "articleBody": "El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.\nEl método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.\nOptimizacion por nivel de esfuerzo Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo\n$$ \\begin{equation} \\frac{\\sigma_e}{\\sigma_m} \u003c RR_i \\end{equation} $$\n$\\sigma_e$ es el esfuerzo de Von Mises del elemento, $\\sigma_m$ es el esfuerzo de Von Mises del modelo y $RR_i$ es el criterio de rechazo. Esta desigualdad define que elementos son removidos después de cada análisis de finitos. Este ciclo se repite hasta que se llegue a un estado de equilibrio, es decir que no hay mas elementos por ser removidos con el criterio de rechazo utilizado. Después de esto se puede aumentar el valor de $RR_i$ para capturar elementos con mayor nivel de esfuerzo y así lograr remover mas material\n$$ \\begin{equation} RR_{i+1} = RR_i + ER \\end{equation} $$\n$ER$ es una tasa evolutiva que se le suma al criterio de rechazo. El método ESO puede ser resumido como:\nDiscretización del modelo en elementos finitos. Realizar un análisis de elementos finitos de la estructura. Remover elementos que satisfacen (1). Aumentar el criterio de rechazo utilizando (2). Repetir los pasos 3 y 4 hasta llegar al punto deseado. Optimización por energía de deformación. Este criterio consiste en tomar la rigidez como factor para llevar a cabo la optimización. Comúnmente llamado cumplimiento medio $C$, es la medida inversa de la rigidez de toda la estructura. El cumplimiento mínimo puede definirse como la energía de deformación total\n$$ \\begin{equation} C = \\frac{1}{2} f^T u \\end{equation} $$\ndonde $f$ y $u$ es el vector de fuerza y desplazamientos respectivamente. El equilibrio de la estructura es definido por:\n$$ \\begin{equation} Ku = f \\end{equation} $$ donde $K$ es la matriz de rigidez global Cuando un elemento es eliminado la matriz de rigidez es reescrita de la siguiente forma:\n$$K^* = K - K_i$$ $$\\Delta K = K^* - K = -K_i$$\n$K^*$ es la matriz modificada después de remover un elemento, $K_i$ es la matriz del elemento. En la ecuación después de eliminar un elemento solo varia el vector de desplazamiento, el cual se describe\n$$ \\begin{equation} \\Delta u = -K^{-1} \\Delta Ku \\end{equation} $$\nde las ecuaciones (3) y (5)\n$$ \\begin{equation} \\Delta C = \\frac{1}{2} f^T \\Delta u = - \\frac{1}{2} f^T k^{-1} \\Delta K u = \\frac{1}{2} u^T_i K_iu_i \\end{equation} $$\ndonde $u_i$ es el vector de desplazamiento del elemento. $\\Delta C$ se entiendo como el numero de sensibilidad del cumplimiento mínimo y es denotado por $\\alpha^e_i$.\n$$ \\begin{equation} \\alpha^e_i = \\frac{1}{2} u^T_i K_iu_i \\end{equation} $$\nEsta ecuación expresa que el incremento en la energía de deformación o cumplimiento mínimo es igual a la energía de deformación del elemento. Para minimizar el cumplimiento mínimo, lo cual es equivalente a maximizar la matriz de rigidez, se eliminan los elementos con menores valores de $\\alpha^e_i$.\nESO con optimización de rigidez se puede resumir en los siguientes pasos:\nDiscretización del modelo en elementos finitos. Realizar un análisis de elementos finitos de la estructura. Calcular el valor de sensibilidad de cada elemento con (7). Remover los elementos con menor valor de sensibilidad de acuerdo con el ratio de rechazo. Repetir los pasos 2 al 4 hasta que el cumplimiento mínimo o máxima deformación se consigue. El método BESO es una versión mejorada del método ESO, ya que este además de eliminar material también añade. Los elementos solidos con un valor de sensibilidad bajo son eliminados y los elementos vacíos con valor de sensibilidad altos se añaden y se convierten en elementos solidos. El valor de sensibilidad de los elementos vacíos es calculado por medio de extrapolación. Para este método el ratio de rechazo $RR$ define el numero de elementos que son eliminados en cada iteración y el ratio de inclusión $IR$ es el que define el aumento del ratio de rechazo.\nUn problema que se presenta en el método ESO es la alta sensibilidad que tiene al aplicar las restricciones, siendo posible conseguir un peor diseño que el inicial. Por lo tanto en este nuevo método el problema de optimización esta mejor planteado para que de esta forma se asegure mejor convergencia\nEl planteamiento del problema al que apunta este método esta definido por:\n$$\\begin{equation} Minimizar\\ C = \\frac{1}{2} f^T u \\end{equation}$$ $$\\begin{equation} V^* - \\sum_{i=1}^N V_i x_i = 0 \\end{equation}$$\n$V^*$ es el volumen de toda la estructura y $v_i$ es el volumen del elemento individual. $x_i$ es una variable que define cuando un elemento esta presente y cuando no lo esta, 1 o 0 respectivamente.\nPara este método el numero de sensibilidad es el descrito por la expresión (7). Cuando el mallado es no uniforme, el numero de sensibilidad debe tener en cuenta el volumen del elemento. De esta forma, el numero de sensibilidad puede ser reemplazado por la densidad de energía de deformación del elemento.\n$$ \\begin{equation} \\alpha^e_i = \\left(\\frac{1}{2} u^T_i K_iu_i\\right)/V_i \\end{equation} $$\nCuando una estructura es discretizada utilizando pocos elementos puede generarse problemas de convergencia debido a que que el numero de sensibilidad se vuelve discontinuo. Para evitar este problema se ideo un filtro que suaviza la sensibilidad por medio de nodos y elementos para evitar la dependencia de mallado.\nPara llevar el filtro de suavizado primero hay que suavizar los nodos, para ello se utiliza la siguiente ecuación\n$$ \\begin{equation} \\alpha^n_j = \\sum_{i=1}^M w_i\\alpha^e_i \\end{equation} $$\ndonde $M$ es el numero de elementos conectados al nodo $j$. $w_i$ es el peso del elemento $i$ y $\\sum_{i=1}^M wi = 1$.\n$$ \\begin{equation} w_i = \\frac{1}{M-1} \\left( 1 - \\frac{r_{ij}}{\\sum_{i=1}^M r_{ij}} \\right) \\end{equation} $$\ndonde $r_{ij}$ es la distancia entre el centro del elemento $i$ y el nodo $j$, de esta forma el peso es mayor cuando el la distancia entre el elemento y el nodo es menor. Después de realizar el suavizado de los nodos se realiza el suavizad de los elementos. Para realizar este esquema se considera la distancia $r_{min}$ que no cambia con el refinamiento de la malla. Este distancia define el radio del dominio $\\omega_i$. El propósito de este dominio es identificar los nodos que van a influenciar la sensibilidad del elemento $i$.\n$$ \\begin{equation} \\alpha_i = \\frac{\\sum_{i=1}^K w(r_{ij}) \\alpha_j^n}{\\sum_{i=1}^K w(r_{ij})} \\end{equation} $$\ndonde K es el numero total de nodos en el dominio $\\omega_i$, $w(r_{ij})$ es el factor de peso definido\n$$ \\begin{equation} w(r_{ij}) = r_{min} - r_{ij}\\ (j=1,2,…,K) \\end{equation} $$\nde esta forma el numero de sensibilidad es suavizado y la sensibilidad de los elementos vació es obtenida. Con este método se consigue resolver el problema generado por la dependencia de la malla, sin embargo esto genera grandes oscilaciones en la función objetivo produciendo problemas de convergencia. Para esto se encontró que al promediar la sensibilidad actual con la anterior resuelve este problema, este promedio se describe por medio de\n$$ \\begin{equation} \\alpha_i = \\frac{\\alpha_i^k + \\alpha_i^{k-1}}{2} \\end{equation} $$\ndonde $k$ es la iteración actual. Para remover y añadir elementos se tiene que calcular previamente el volumen objetivo de la siguiente iteración $V_{k+1}$. Debido a que la restricción de volumen $v^*$ puede ser mayor o menor que el volumen inicial, el volumen objetivo puede aumentar o disminuir. El volumen evoluciona de la siguiente forma\n$$ \\begin{equation} V_{k+1} = V_k(1 \\pm ER)\\ (k=1,2,3,…) \\end{equation} $$\ndonde $ER$ es el ratio de evolución del volumen. Una vez la restricción de volumen es cumplida, el volumen de la siguiente iteración seguir constante.\nAl calcular la sensibilidad de los elementos estos son ordenados de mayor a menor. Para los elementos solidos que serán eliminados\n$$\\alpha_i \\leq \\alpha_{del}^{th}$$\npara los elementos vacíos que serán añadidos\n$$\\alpha_i \u003e \\alpha_{add}^{th}$$\nPara calcular los valores de $\\alpha_{add}^{th}$ y $\\alpha_{del}^{th}$ hay que seguir los siguientes pasos:\ndejar $\\alpha_{add}^{th} = \\alpha_{del}^{th} = \\alpha_{th}$. Si se tienen 1000 elementos y con las sensibilidades ordenadas $\\alpha_1 \u003e \\alpha_2 \u003e … \u003e \\alpha_{1000}$ y $V_{k+1}$ corresponde a un diseño con 600 elementos entonces $\\alpha_{th} = \\alpha_{600}$\nCalcular la razón de adición de volumen $AR$, la cual es calcula da dividiendo el numero de elementos añadidos por el numero total de elementos. Si $AR \\leq AR_{max}$ entonces no realizar el paso 3. De otra forma hay que recalcular $\\alpha_{add}^{th}$ y $\\alpha_{del}^{th}$.\nPara calcular $\\alpha_{add}^{th}$ ordenar la sensibilidad de los elementos vacíos. El numero de elementos que van a cambiar de 0 a 1 sera igual a $AR_{max}$ multiplicado el numero de elemento total. $\\alpha_{add}^{th}$ es la sensibilidad del elemento clasificado justo debajo del ultimo elemento añadido. $\\alpha_{add}^{th}$ es determinado para que el volumen eliminado sea igual a $V_k - V_{k-1} + volumen del elemento añadido$.\nEl ciclo de análisis de elemento finitos y remover/añadir elementos continua hasta que se llegue a la restricción de volumen $V^*$ o se consiga el siguiente criterio de convergencia\n$$ \\begin{equation} error = \\frac{\\sum^N_{i=1} C_{k-i+1} - \\sum^N_{i=1} C_{k-N-i+1}}{\\sum^N_{i=1} C_{k-i+1}} \\leq \\tau \\end{equation} $$\ndonde $k$ es la iteración actual, $\\tau$ es la tolerancia de la convergencia permitida y $N$ es un numero entero. Normalmente, $N$ es $5$, ya que implica que el cambio en el cumplimiento mínimo sobre las ultimas 10 iteraciones es aceptablemente pequeño.\nEl método BESO puede ser resumido en los siguientes pasos:\nDiscretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento. Realizar el análisis de elementos finito y calcular la sensibilidad de acuerdo con (13). Promediar la sensibilidad de la sensibilidad con el historial y guardar el resultado para la siguiente iteración (15). Determinar el volumen objetivo para la siguiente iteración (16). Añadir y eliminar elementos. repetir los pasos del 2 al 5 hasta llegar al volumen $V^*$ o que el criterio de convergencia (17) se satisfaga. Referencias Yago, D., Cante, J., Lloberas-Valls, O., \u0026 Oliver, J. (2022). Topology Optimization Methods for 3D Structural Problems: A Comparative Study. Archives of Computational Methods in Engineering, 29(3), 1525–1567. doi:10.1007/s11831-021-09626-2 Huang, X., \u0026 Xie, M. (2010). Evolutionary Topology Optimization of Continuum Structures: Methods and Applications. John Wiley \u0026 Sons. ",
  "wordCount" : "1700",
  "inLanguage": "es",
  "datePublished": "2023-03-15T11:48:52-05:00",
  "dateModified": "2023-03-15T11:48:52-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://kssgarcia.github.io/es/posts/eso_beso/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kssgarcia",
    "logo": {
      "@type": "ImageObject",
      "url": "http://kssgarcia.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://kssgarcia.github.io/es/" accesskey="h" title="Kssgarcia (Alt + H)">Kssgarcia</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://kssgarcia.github.io/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://kssgarcia.github.io/es/" title="Kssgarcia">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://kssgarcia.github.io/es/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://kssgarcia.up.railway.app/" title="Portafolio">
                    <span>Portafolio</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

    
    <h1 class="post-title">
      ESO/BESO
    </h1>
    <div class="post-meta"><span title='2023-03-15 11:48:52 -0500 -05'>marzo 15, 2023</span>&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://kssgarcia.github.io/posts/eso_beso/">En</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><p>El método ESO (evolutionary structural optimization) y BESO (bi-directional evolutionary structural optimization) son metodos con criterio de optimización hard-kill, es decir que puede eliminar material y esto hace que el dominio se vea modificado.</p>
<p>El método ESO consiste en el simple concepto de ir removiendo material que es ineficiente. Esto se realiza calculando los esfuerzos en todo el modelo y eliminando los elementos que presentan valores bajos.</p>
<h2 id="optimizacion-por-nivel-de-esfuerzo">Optimizacion por nivel de esfuerzo<a hidden class="anchor" aria-hidden="true" href="#optimizacion-por-nivel-de-esfuerzo">#</a></h2>
<p>Para esto se calcula el nivel de esfuerzo de cada elemento y se compara con criterio definido como criterio de rechazo</p>
<p>$$
\begin{equation}
\frac{\sigma_e}{\sigma_m} &lt; RR_i
\end{equation}
$$</p>
<p>$\sigma_e$ es el esfuerzo de Von Mises del elemento, $\sigma_m$ es el esfuerzo de Von Mises del modelo y $RR_i$ es el criterio de rechazo. Esta desigualdad define que elementos son removidos después de cada análisis de finitos. Este ciclo se repite hasta que se llegue a un estado de equilibrio, es decir que no hay mas elementos por ser removidos con el criterio de rechazo utilizado. Después de esto se puede aumentar el valor de $RR_i$ para capturar elementos con mayor nivel de esfuerzo y así lograr remover mas material</p>
<p>$$
\begin{equation}
RR_{i+1} = RR_i + ER
\end{equation}
$$</p>
<p>$ER$ es una tasa evolutiva que se le suma al criterio de rechazo. El método ESO puede ser resumido como:</p>
<ol>
<li> Discretización del modelo en elementos finitos.</li>
<li> Realizar un análisis de elementos finitos de la estructura.</li>
<li> Remover elementos que satisfacen (1).</li>
<li> Aumentar el criterio de rechazo utilizando (2).</li>
<li> Repetir los pasos 3 y 4 hasta llegar al punto deseado.</li>
</ol>
<h2 id="optimización-por-energía-de-deformación">Optimización por energía de deformación.<a hidden class="anchor" aria-hidden="true" href="#optimización-por-energía-de-deformación">#</a></h2>
<p>Este criterio consiste en tomar la rigidez como factor para llevar a cabo la optimización. Comúnmente llamado cumplimiento medio $C$, es la medida inversa de la rigidez de toda la estructura. El cumplimiento mínimo puede definirse como la energía de deformación total</p>
<p>$$
\begin{equation}
C = \frac{1}{2} f^T u
\end{equation}
$$</p>
<p>donde $f$ y $u$ es el vector de fuerza y desplazamientos respectivamente. El equilibrio de la estructura es definido por:</p>
<p>$$
\begin{equation}
Ku = f \end{equation}
$$
donde $K$ es la matriz de rigidez global Cuando un elemento es eliminado la matriz de rigidez es reescrita de la siguiente forma:</p>
<p>$$K^* = K - K_i$$ $$\Delta K = K^* - K = -K_i$$</p>
<p>$K^*$ es la matriz modificada después de remover un elemento, $K_i$ es la matriz del elemento. En la ecuación después de eliminar un elemento solo varia el vector de desplazamiento, el cual se describe</p>
<p>$$
\begin{equation}
\Delta u = -K^{-1} \Delta Ku
\end{equation}
$$</p>
<p>de las ecuaciones (3) y (5)</p>
<p>$$
\begin{equation}
\Delta C = \frac{1}{2} f^T \Delta u = - \frac{1}{2} f^T k^{-1} \Delta K u = \frac{1}{2} u^T_i K_iu_i
\end{equation}
$$</p>
<p>donde $u_i$ es el vector de desplazamiento del elemento. $\Delta C$ se entiendo como el numero de sensibilidad del cumplimiento mínimo y es denotado por $\alpha^e_i$.</p>
<p>$$
\begin{equation}
\alpha^e_i = \frac{1}{2} u^T_i K_iu_i
\end{equation}
$$</p>
<p>Esta ecuación expresa que el incremento en la energía de deformación o cumplimiento mínimo es igual a la energía de deformación del elemento. Para minimizar el cumplimiento mínimo, lo cual es equivalente a maximizar la matriz de rigidez, se eliminan los elementos con menores valores de $\alpha^e_i$.</p>
<p>ESO con optimización de rigidez se puede resumir en los siguientes pasos:</p>
<ol>
<li> Discretización del modelo en elementos finitos.</li>
<li> Realizar un análisis de elementos finitos de la estructura.</li>
<li> Calcular el valor de sensibilidad de cada elemento con (7).</li>
<li> Remover los elementos con menor valor de sensibilidad de acuerdo con el ratio de rechazo.</li>
<li> Repetir los pasos 2 al 4 hasta que el cumplimiento mínimo o máxima deformación se consigue.</li>
</ol>
<p>El método BESO es una versión mejorada del método ESO, ya que este además de eliminar material también añade. Los elementos solidos con un valor de sensibilidad bajo son eliminados y los elementos vacíos con valor de sensibilidad altos se añaden y se convierten en elementos solidos. El valor de sensibilidad de los elementos vacíos es calculado por medio de extrapolación. Para este método el ratio de rechazo $RR$ define el numero de elementos que son eliminados en cada iteración y el ratio de inclusión $IR$ es el que define el aumento del ratio de rechazo.</p>
<p>Un problema que se presenta en el método ESO es la alta sensibilidad que tiene al aplicar las restricciones, siendo posible conseguir un peor diseño que el inicial. Por lo tanto en este nuevo método el problema de optimización esta mejor planteado para que de esta forma se asegure mejor convergencia</p>
<p>El planteamiento del problema al que apunta este método esta definido por:</p>
<p>$$\begin{equation}
    Minimizar\ C = \frac{1}{2} f^T u
\end{equation}$$
$$\begin{equation}
    V^* - \sum_{i=1}^N V_i x_i = 0
\end{equation}$$</p>
<p>$V^*$ es el volumen de toda la estructura y $v_i$ es el volumen del elemento individual. $x_i$ es una variable que define cuando un elemento esta presente y cuando no lo esta, 1 o 0 respectivamente.</p>
<p>Para este método el numero de sensibilidad es el descrito por la expresión (7). Cuando el mallado es no uniforme, el numero de sensibilidad debe tener en cuenta el volumen del elemento. De esta forma, el numero de sensibilidad puede ser reemplazado por la densidad de energía de deformación del elemento.</p>
<p>$$
\begin{equation}
\alpha^e_i = \left(\frac{1}{2} u^T_i K_iu_i\right)/V_i
\end{equation}
$$</p>
<p>Cuando una estructura es discretizada utilizando pocos elementos puede generarse problemas de convergencia debido a que que el numero de sensibilidad se vuelve discontinuo. Para evitar este problema se ideo un filtro que suaviza la sensibilidad por medio de nodos y elementos para evitar la dependencia de mallado.</p>
<p>Para llevar el filtro de suavizado primero hay que suavizar los nodos, para ello se utiliza la siguiente ecuación</p>
<p>$$
\begin{equation}
\alpha^n_j = \sum_{i=1}^M w_i\alpha^e_i
\end{equation}
$$</p>
<p>donde $M$ es el numero de elementos conectados al nodo $j$. $w_i$ es el peso del elemento $i$ y $\sum_{i=1}^M wi = 1$.</p>
<p>$$
\begin{equation}
w_i = \frac{1}{M-1} \left( 1 - \frac{r_{ij}}{\sum_{i=1}^M r_{ij}} \right)
\end{equation}
$$</p>
<p>donde $r_{ij}$ es la distancia entre el centro del elemento $i$ y el nodo $j$, de esta forma el peso es mayor cuando el la distancia entre el elemento y el nodo es menor. Después de realizar el suavizado de los nodos se realiza el suavizad de los elementos. Para realizar este esquema se considera la distancia $r_{min}$ que no cambia con el refinamiento de la malla. Este distancia define el radio del dominio $\omega_i$. El propósito de este dominio es identificar los nodos que van a influenciar la sensibilidad del elemento $i$.</p>
<p>$$
\begin{equation}
\alpha_i = \frac{\sum_{i=1}^K w(r_{ij}) \alpha_j^n}{\sum_{i=1}^K w(r_{ij})}
\end{equation}
$$</p>
<p>donde K es el numero total de nodos en el dominio $\omega_i$, $w(r_{ij})$ es el factor de peso definido</p>
<p>$$
\begin{equation}
w(r_{ij}) = r_{min} - r_{ij}\ (j=1,2,&hellip;,K)
\end{equation}
$$</p>
<p>de esta forma el numero de sensibilidad es suavizado y la sensibilidad de los elementos vació es obtenida. Con este método se consigue resolver el problema generado por la dependencia de la malla, sin embargo esto genera grandes oscilaciones en la función objetivo produciendo problemas de convergencia. Para esto se encontró que al promediar la sensibilidad actual con la anterior resuelve este problema, este promedio se describe por medio de</p>
<p>$$
\begin{equation}
\alpha_i = \frac{\alpha_i^k + \alpha_i^{k-1}}{2}
\end{equation}
$$</p>
<p>donde $k$ es la iteración actual.
Para remover y añadir elementos se tiene que calcular previamente el volumen objetivo de la siguiente iteración $V_{k+1}$. Debido a que la restricción de volumen $v^*$ puede ser mayor o menor que el volumen inicial, el volumen objetivo puede aumentar o disminuir. El volumen evoluciona de la siguiente forma</p>
<p>$$
\begin{equation}
V_{k+1} = V_k(1 \pm ER)\ (k=1,2,3,&hellip;)
\end{equation}
$$</p>
<p>donde $ER$ es el ratio de evolución del volumen. Una vez la restricción de volumen es cumplida, el volumen de la siguiente iteración seguir constante.</p>
<p>Al calcular la sensibilidad de los elementos estos son ordenados de mayor a menor. Para los elementos solidos que serán eliminados</p>
<p>$$\alpha_i \leq \alpha_{del}^{th}$$</p>
<p>para los elementos vacíos que serán añadidos</p>
<p>$$\alpha_i &gt; \alpha_{add}^{th}$$</p>
<p>Para calcular los valores de $\alpha_{add}^{th}$ y $\alpha_{del}^{th}$ hay que seguir los siguientes pasos:</p>
<ol>
<li>
<p> dejar $\alpha_{add}^{th} = \alpha_{del}^{th} = \alpha_{th}$. Si se tienen 1000 elementos y con las sensibilidades ordenadas $\alpha_1 &gt; \alpha_2 &gt; &hellip; &gt; \alpha_{1000}$ y $V_{k+1}$ corresponde a un diseño con 600 elementos entonces $\alpha_{th} = \alpha_{600}$</p>
</li>
<li>
<p> Calcular la razón de adición de volumen $AR$, la cual es calcula da dividiendo el numero de elementos añadidos por el numero total de elementos. Si $AR \leq AR_{max}$ entonces no realizar el paso 3. De otra forma hay que recalcular $\alpha_{add}^{th}$ y $\alpha_{del}^{th}$.</p>
</li>
<li>
<p> Para calcular $\alpha_{add}^{th}$ ordenar la sensibilidad de los elementos vacíos. El numero de elementos que van a cambiar de 0 a 1 sera igual a $AR_{max}$ multiplicado el numero de elemento total. $\alpha_{add}^{th}$ es la sensibilidad del elemento clasificado justo debajo del ultimo elemento añadido. $\alpha_{add}^{th}$ es determinado para que el volumen eliminado sea igual a $V_k - V_{k-1} + volumen del elemento añadido$.</p>
</li>
</ol>
<p>El ciclo de análisis de elemento finitos y remover/añadir elementos continua hasta que se llegue a la restricción de volumen $V^*$ o se consiga el siguiente criterio de convergencia</p>
<p>$$
\begin{equation}
error = \frac{\sum^N_{i=1} C_{k-i+1} - \sum^N_{i=1} C_{k-N-i+1}}{\sum^N_{i=1} C_{k-i+1}} \leq \tau
\end{equation}
$$</p>
<p>donde $k$ es la iteración actual, $\tau$ es la tolerancia de la convergencia permitida y $N$ es un numero entero. Normalmente, $N$ es $5$, ya que implica que el cambio en el cumplimiento mínimo sobre las ultimas 10 iteraciones es aceptablemente pequeño.</p>
<p>El método BESO puede ser resumido en los siguientes pasos:</p>
<ol>
<li> Discretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento.</li>
<li> Realizar el análisis de elementos finito y calcular la sensibilidad de acuerdo con (13).</li>
<li> Promediar la sensibilidad de la sensibilidad con el historial y guardar el resultado para la siguiente iteración (15).</li>
<li> Determinar el volumen objetivo para la siguiente iteración (16).</li>
<li> Añadir y eliminar elementos.</li>
<li> repetir los pasos del 2 al 5 hasta llegar al volumen $V^*$ o que el criterio de convergencia (17) se satisfaga.</li>
</ol>
<h2 id="referencias">Referencias<a hidden class="anchor" aria-hidden="true" href="#referencias">#</a></h2>
<ul>
<li>Yago, D., Cante, J., Lloberas-Valls, O., &amp; Oliver, J. (2022). Topology Optimization Methods for 3D Structural Problems: A Comparative Study. Archives of Computational Methods in Engineering, 29(3), 1525–1567. doi:10.1007/s11831-021-09626-2</li>
<li>Huang, X., &amp; Xie, M. (2010). Evolutionary Topology Optimization of Continuum Structures: Methods and Applications. John Wiley &amp; Sons.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://kssgarcia.github.io/es/">Kssgarcia</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>
</html>
