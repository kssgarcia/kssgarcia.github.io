<!DOCTYPE html>
<html lang="es" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Código de optimización BESO | Kssgarcia</title>
<meta name="keywords" content="">
<meta name="description" content="En esta publicación, presentaré un código Python para el método de optimización de BESO.
Planteamiento del problema Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.
Figura 1. Diagrama de vigas. Primero, consideremos los siguientes pasos para hacer el algoritmo:
Discretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento.">
<meta name="author" content="">
<link rel="canonical" href="http://kssgarcia.github.io/es/posts/beso/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bf5f9f73cf17311d52cedbcda82c922e91b2f566d88a85ad9f5b5a08b586bd5f.css" integrity="sha256-v1&#43;fc88XMR1SztvNqCySLpGy9WbYioWtn1taCLWGvV8=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://kssgarcia.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://kssgarcia.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://kssgarcia.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://kssgarcia.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://kssgarcia.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://kssgarcia.github.io/posts/beso/">
<link rel="alternate" hreflang="es" href="http://kssgarcia.github.io/es/posts/beso/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Código de optimización BESO" />
<meta property="og:description" content="En esta publicación, presentaré un código Python para el método de optimización de BESO.
Planteamiento del problema Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.
Figura 1. Diagrama de vigas. Primero, consideremos los siguientes pasos para hacer el algoritmo:
Discretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://kssgarcia.github.io/es/posts/beso/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-24T11:48:52-05:00" />
<meta property="article:modified_time" content="2023-04-24T11:48:52-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Código de optimización BESO"/>
<meta name="twitter:description" content="En esta publicación, presentaré un código Python para el método de optimización de BESO.
Planteamiento del problema Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.
Figura 1. Diagrama de vigas. Primero, consideremos los siguientes pasos para hacer el algoritmo:
Discretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://kssgarcia.github.io/es/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Código de optimización BESO",
      "item": "http://kssgarcia.github.io/es/posts/beso/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Código de optimización BESO",
  "name": "Código de optimización BESO",
  "description": "En esta publicación, presentaré un código Python para el método de optimización de BESO.\nPlanteamiento del problema Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.\nFigura 1. Diagrama de vigas. Primero, consideremos los siguientes pasos para hacer el algoritmo:\nDiscretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento.",
  "keywords": [
    
  ],
  "articleBody": "En esta publicación, presentaré un código Python para el método de optimización de BESO.\nPlanteamiento del problema Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.\nFigura 1. Diagrama de vigas. Primero, consideremos los siguientes pasos para hacer el algoritmo:\nDiscretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento. Realice el análisis de elementos finitos y calcule la sensibilidad según. Promedie la sensibilidad de la sensibilidad con el historial y guarde el resultado para la siguiente iteración. Determine el volumen objetivo para la siguiente iteración. Agregar y eliminar elementos. Repita los pasos 2 a 5 hasta alcanzar el volumen óptimo o satisfacer el criterio de convergencia. Discretización La discretización se realiza con la siguiente función con la ayuda de numpy\ndef beam(L=10, H=10, F=-1000000, E=206.8e9, v=0.28, nx=20, ny=20): \"\"\" Make the mesh for a cuadrilateral model. Parameters ---------- L : float (optional) Beam's lenght H : float (optional) Beam's height F : float (optional) Vertical force. E : string (optional) Young module v : string (optional) Poisson ratio nx : int (optional) Number of element in x direction ny : int (optional) Number of element in y direction Returns ------- nodes : ndarray Nodes array mats : ndarray (1, 2) Mats array els : ndarray Elements array loads : ndarray Loads array BC : ndarray Boundary conditions nodes \"\"\" mats = np.array([[E,v]]) x, y, els = pre.rect_grid(L, H, nx, ny) nodes = np.zeros(((nx + 1)*(ny + 1), 5)) nodes[:, 0] = range((nx + 1)*(ny + 1)) nodes[:, 1] = x nodes[:, 2] = y mask = (x==L/2) nodes[mask, 3:] = -1 mask_loads = (x == -L/2) \u0026 (y \u003c H/6) \u0026 (y \u003e -H/6) loads_nodes = nodes[mask_loads, 0] loads = np.zeros((len(loads_nodes), 3)) loads[:, 0] = loads_nodes loads[:, 2] = F BC = nodes[mask, 0] return nodes, mats, els, loads, BC con esta función se definen las variables necesarias para hacer análisis de elementos finitos\nlength = 20 height = 10 nx = 50 ny= 20 nodes, mats, els, loads, BC = beam_2(L=length, H=height, nx=nx, ny=ny) elsI,nodesI = np.copy(els), np.copy(nodes) IBC, UG = preprocessing(nodes, mats, els, loads) UCI, E_nodesI, S_nodesI = postprocessing(nodes, mats, els, IBC, UG) Análisis de elementos finitos Con estas variables ya podemos resolver el problema y obtener los desplazamientos, deformaciones y tensiones. Para calcular el análisis de elementos finitos se utiliza la biblioteca Solidspy 1.0.16.\ndef preprocessing(nodes, mats, els, loads): \"\"\" Compute IBC matrix and the static solve. Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py Parameters ---------- nodes : ndarray Array with models nodes mats : ndarray Array with models materials els : ndarray Array with models elements loads : ndarray Array with models loads Returns ------- bc_array : ndarray Boundary conditions array disp : ndarray Static displacement solve rh_vec : ndarray Vector of loads \"\"\" assem_op, bc_array, neq = ass.DME(nodes[:, -2:], els, ndof_el_max=8) print(\"Number of elements: {}\".format(els.shape[0])) # System assembly stiff_mat, _ = ass.assembler(els, mats, nodes[:, :3], neq, assem_op) rhs_vec = ass.loadasem(loads, bc_array, neq) # System solution disp = sol.static_sol(stiff_mat, rhs_vec) if not np.allclose(stiff_mat.dot(disp)/stiff_mat.max(), rhs_vec/stiff_mat.max()): print(\"The system is not in equilibrium!\") return bc_array, disp, rhs_vec def postprocessing(nodes, mats, els, bc_array, disp): \"\"\" Compute the nodes displacements, strains and stresses. Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py Parameters ---------- nodes : ndarray Array with models nodes mats : ndarray Array with models materials els : ndarray Array with models elements bc_array : ndarray Boundary conditions array disp : ndarray Static solve Returns ------- disp_complete : ndarray Displacements at elements. strain_nodes : ndarray Strains at elements stress_nodes : ndarray Stresses at elements \"\"\" disp_complete = pos.complete_disp(bc_array, nodes, disp) strain_nodes, stress_nodes = None, None strain_nodes, stress_nodes = pos.strain_nodes(nodes, els, mats, disp_complete) return disp_complete, strain_nodes, stress_nodes Optimización def is_equilibrium(nodes, mats, els, loads): \"\"\" Check if the system is in equilibrium Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py Parameters ---------- nodes : ndarray Array with models nodes mats : ndarray Array with models materials els : ndarray Array with models elements loads : ndarray Array with models loads Returns ------- equil : bool Variable True when the system is in equilibrium and False when it doesn't \"\"\" equil = True assem_op, bc_array, neq = ass.DME(nodes[:, -2:], els, ndof_el_max=8) stiff_mat, _ = ass.assembler(els, mats, nodes[:, :3], neq, assem_op) rhs_vec = ass.loadasem(loads, bc_array, neq) disp = sol.static_sol(stiff_mat, rhs_vec) if not np.allclose(stiff_mat.dot(disp)/stiff_mat.max(), rhs_vec/stiff_mat.max()): equil = False return equil def protect_els(els, nels, loads, BC): \"\"\" Compute an mask array with the elements that don't must be deleted. Parameters ---------- els : ndarray Array with models elements nels : ndarray Number of elements loads : ndarray Array with models loads BC : ndarray Boundary conditions nodes Returns ------- mask_els : ndarray Array with the elements that don't must be deleted. \"\"\" mask_els = np.zeros(nels, dtype=bool) protect_nodes = np.hstack((loads[:,0], BC)).astype(int) protect_index = None for p in protect_nodes: protect_index = np.argwhere(els[:, -4:] == p)[:,0] mask_els[els[protect_index,0]] = True return mask_els def del_node(nodes, els, loads, BC): \"\"\" Retricts nodes dof that aren't been used and free up the nodes that are in use. Parameters ---------- nodes : ndarray Array with models nodes els : ndarray Array with models elements loads : ndarray Array with models loads BC : ndarray Boundary conditions nodes Returns ------- \"\"\" protect_nodes = np.hstack((loads[:,0], BC)).astype(int) for n in nodes[:,0]: if n not in els[:, -4:]: nodes[int(n), -2:] = -1 elif n not in protect_nodes and n in els[:, -4:]: nodes[int(n), -2:] = 0 def volume(els, length, height, nx, ny): \"\"\" Volume calculation. Parameters ---------- els : ndarray Array with models elements. length : ndarray Length of the beam. height : ndarray Height of the beam. nx : float Number of elements in x direction. ny : float Number of elements in y direction. Return ---------- V: float \"\"\" dy = length / nx dx = height / ny V = dx * dy * np.ones(els.shape[0]) return V def sensitivity_els(nodes, mats, els, mask, UC): \"\"\" Calculate the sensitivity number for each element. Parameters ---------- nodes : ndarray Array with models nodes mats : ndarray Array with models materials els : ndarray Array with models elements mask : ndarray Mask of optimal estructure UC : ndarray Displacements at nodes Returns ------- sensi_number : ndarray Sensitivity number for each element. \"\"\" sensi_number = [] for el in range(els.shape[0]): if mask[el] == False: sensi_number.append(0) continue params = tuple(mats[els[el, 2], :]) elcoor = nodes[els[el, -4:], 1:3] kloc, _ = uel.elast_quad4(elcoor, params) node_el = els[el, -4:] U_el = UC[node_el] U_el = np.reshape(U_el, (8,1)) a_i = 0.5 * U_el.T.dot(kloc.dot(U_el))[0,0] sensi_number.append(a_i) sensi_number = np.array(sensi_number) sensi_number = sensi_number/sensi_number.max() return sensi_number def adjacency_nodes(nodes, els): \"\"\" Create an adjacency matrix for the elements connected to each node. Parameters ---------- nodes : ndarray Array with models nodes. els : ndarray Array with models elements. Returns ------- adj_nodes : ndarray, nodes.shape[0] Adjacency elements for each node. \"\"\" adj_nodes = [] for n in nodes[:, 0]: adj_els = np.argwhere(els[:, -4:] == n)[:,0] adj_nodes.append(adj_els) return adj_nodes def center_els(nodes, els): \"\"\" Calculate the center of each element. Parameters ---------- nodes : ndarray Array with models nodes. els : ndarray Array with models elements. Returns ------- centers : ndarray, nodes.shape[0] Adjacency elements for each node. \"\"\" centers = [] for el in els: n = nodes[el[-4:], 1:3] center = np.array([n[1,0] + (n[0,0] - n[1,0])/2, n[2,1] + (n[0,1] - n[2,1])/2]) centers.append(center) centers = np.array(centers) return centers def sensitivity_nodes(nodes, adj_nodes, centers, sensi_els): \"\"\" Calculate the sensitivity of each node. Parameters ---------- nodes : ndarray Array with models nodes adj_nodes : ndarray Adjacency matrix of nodes centers : ndarray Array with center of elements sensi_els : ndarra Sensitivity of each element without filter Returns ------- sensi_nodes : ndarray Sensitivity of each nodes \"\"\" sensi_nodes = [] for n in nodes: connected_els = adj_nodes[int(n[0])] if connected_els.shape[0] \u003e 1: delta = centers[connected_els] - n[1:3] r_ij = np.linalg.norm(delta, axis=1) # We can remove this line and just use a constant because the distance is always the same w_i = 1/(connected_els.shape[0] - 1) * (1 - r_ij/r_ij.sum()) sensi = (w_i * sensi_els[connected_els]).sum(axis=0) else: sensi = sensi_els[connected_els[0]] sensi_nodes.append(sensi) sensi_nodes = np.array(sensi_nodes) return sensi_nodes def sensitivity_filter(nodes, centers, sensi_nodes, r_min): \"\"\" Performe the sensitivity filter. Parameters ---------- nodes : ndarray Array with models nodes sensi_nodes : ndarray Array with nodal sensitivity centers : ndarray Array with center of elements r_min : ndarra Minimum distance Returns ------- sensi_els : ndarray Sensitivity of each element with filter \"\"\" sensi_els = [] for i, c in enumerate(centers): delta = nodes[:,1:3]-c r_ij = np.linalg.norm(delta, axis=1) omega_i = (r_ij \u003c r_min) w = 1/(omega_i.sum() - 1) * (1 - r_ij[omega_i]/r_ij[omega_i].sum()) sensi_els.append((w*sensi_nodes[omega_i]).sum()/w.sum()) sensi_els = np.array(sensi_els) sensi_els = sensi_els/sensi_els.max() return sensi_els Primero definamos el número de iteraciones nitro, ERR la relación de rechazo evolutivo y t la tolerancia de convergencia permitida, el radio mínimo r_min y el volumen óptimo V_opt. Después de definir estas variables, calculamos la matriz de adyacencia para los nodos adjacency_nodes() y el centro de cada elemento center_els(), estas matrices se utilizarán para lograr el esquema de filtro.\nLa secuencia del bucle se define con:\nniter = 200 ERR = 0.005 t = 0.01 r_min = np.linalg.norm(nodes[0,1:3] - nodes[1,1:3]) * 1.5 adj_nodes = adjacency_nodes(nodes, els) centers = center_els(nodes, els) Vi = volume(els, length, height, nx, ny) V_opt = Vi.sum() * 0.50 # Initialize variables. ELS = None mask = np.ones(els.shape[0], dtype=bool) sensi_I = None C_h = np.zeros(niter) error = 1000 for i in range(niter): # Calculate the optimal design array elements els_del = els[mask].copy() V = Vi[mask].sum() # Check equilibrium if not is_equilibrium(nodes, mats, els_del, loads): print('Is not equilibrium') break # Storage the solution ELS = els_del # FEW analysis IBC, UG, rhs_vec = preprocessing(nodes, mats, els_del, loads) UC, E_nodes, S_nodes = postprocessing(nodes, mats, els_del, IBC, UG) # Sensitivity filter sensi_e = sensitivity_els(nodes, mats, els, mask, UC) sensi_nodes = sensitivity_nodes(nodes, adj_nodes, centers, sensi_e) #3.4 sensi_number = sensitivity_filter(nodes, centers, sensi_nodes, r_min) #3.6 # Avarage the sensitivity numbers to the historical information if i \u003e 0: sensi_number = (sensi_number + sensi_I)/2 # 3.8 sensi_number = sensi_number/sensi_number.max() # Check if the optimal volume is reached and calculate the next volume V_r = False if V \u003c= V_opt: els_k = els_del.shape[0] V_r = True break else: V_k = V * (1 + ERR) if V \u003c V_opt else V * (1 - ERR) # Remove/add threshold sensi_sort = np.sort(sensi_number)[::-1] els_k = els_del.shape[0]*V_k/V alpha_del = sensi_sort[int(els_k)] # Remove/add elements mask = sensi_number \u003e alpha_del mask_els = protect_els(els[np.invert(mask)], els.shape[0], loads, BC) mask = np.bitwise_or(mask, mask_els) del_node(nodes, els[mask], loads, BC) # Calculate the strain energy and storage it C = 0.5*rhs_vec.T@UG C_h[i] = C if i \u003e 10: error = C_h[i-5:].sum() - C_h[i-10:-5].sum()/C_h[i-5:].sum() # Check for convergence if error \u003c= t and V_r == True: print(\"convergence\") break # Save the sensitvity number for the next iteration sensi_I = sensi_number.copy() Resultados Como se puede apreciar en la figura 2 se presentan los resultados del ejercicio propuesto al inicio del post, para el gráfico 2.a se evidencia que el método converge a una estructura óptima. En este programa BESO, la dependencia de la malla y los problemas del patrón de tablero de ajedrez se consideran bajo el esquema de filtro 2.d.\nFigura 2. Topologías BESO para vigas en voladizo con diferente fracción de volumen: (a) 80%; (b) 70%; c) 60 %; (d) 50%. Referencias [1] Nabaki, K., Shen, J. y Huang, X. (2019). Optimización topológica evolutiva de estructuras continuas considerando falla por fatiga. Materiales y diseño, 166, 107586. doi:10.1016/j.matdes.2019.107586\n",
  "wordCount" : "1884",
  "inLanguage": "es",
  "datePublished": "2023-04-24T11:48:52-05:00",
  "dateModified": "2023-04-24T11:48:52-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://kssgarcia.github.io/es/posts/beso/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kssgarcia",
    "logo": {
      "@type": "ImageObject",
      "url": "http://kssgarcia.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://kssgarcia.github.io/es/" accesskey="h" title="Kssgarcia (Alt + H)">Kssgarcia</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://kssgarcia.github.io/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://kssgarcia.github.io/es/" title="Kssgarcia">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://kssgarcia.github.io/es/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://kssgarcia.up.railway.app/" title="Portafolio">
                    <span>Portafolio</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

    
    <h1 class="post-title">
      Código de optimización BESO
    </h1>
    <div class="post-meta"><span title='2023-04-24 11:48:52 -0500 -05'>abril 24, 2023</span>&nbsp;|&nbsp;Traducciones:
<ul class="i18n_list">
    <li>
        <a href="http://kssgarcia.github.io/posts/beso/">En</a>
    </li>
</ul>

</div>
  </header> 
  <div class="post-content"><p>En esta publicación, presentaré un código Python para el método de optimización de BESO.</p>
<h3 id="planteamiento-del-problema">Planteamiento del problema<a hidden class="anchor" aria-hidden="true" href="#planteamiento-del-problema">#</a></h3>
<p>Consideremos una viga en voladizo con una fuerza vertical de 10kN, dimensiones 20x10 metros, módulo joven de 206.8 GPa y relación de Poisson 0.28 figura 1 $RR=0.01$, $ERR=0.005$.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img loading="lazy" src="/ESO_model.png" alt="Scenario 1: Across columns"  />
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><!-- raw HTML omitted -->Figura 1. Diagrama de vigas.<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<p>Primero, consideremos los siguientes pasos para hacer el algoritmo:</p>
<ol>
<li>Discretizar el dominio y asignar la propiedad inicial, 0 o 1, para cada elemento.</li>
<li>Realice el análisis de elementos finitos y calcule la sensibilidad según.</li>
<li>Promedie la sensibilidad de la sensibilidad con el historial y guarde el resultado para la siguiente iteración.</li>
<li>Determine el volumen objetivo para la siguiente iteración.</li>
<li>Agregar y eliminar elementos.</li>
<li>Repita los pasos 2 a 5 hasta alcanzar el volumen óptimo o satisfacer el criterio de convergencia.</li>
</ol>
<h3 id="discretización">Discretización<a hidden class="anchor" aria-hidden="true" href="#discretización">#</a></h3>
<p>La discretización se realiza con la siguiente función con la ayuda de numpy</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">beam</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">F</span><span class="o">=-</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="mf">206.8e9</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="mf">0.28</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Make the mesh for a cuadrilateral model.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    L : float (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Beam&#39;s lenght
</span></span></span><span class="line"><span class="cl"><span class="s2">    H : float (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Beam&#39;s height
</span></span></span><span class="line"><span class="cl"><span class="s2">    F : float (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Vertical force.
</span></span></span><span class="line"><span class="cl"><span class="s2">    E : string (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Young module
</span></span></span><span class="line"><span class="cl"><span class="s2">    v : string (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Poisson ratio
</span></span></span><span class="line"><span class="cl"><span class="s2">    nx : int (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of element in x direction
</span></span></span><span class="line"><span class="cl"><span class="s2">    ny : int (optional)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of element in y direction
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Nodes array
</span></span></span><span class="line"><span class="cl"><span class="s2">    mats : ndarray (1, 2)
</span></span></span><span class="line"><span class="cl"><span class="s2">        Mats array
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Elements array
</span></span></span><span class="line"><span class="cl"><span class="s2">    loads : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Loads array
</span></span></span><span class="line"><span class="cl"><span class="s2">    BC : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Boundary conditions nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">E</span><span class="p">,</span><span class="n">v</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">els</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">rect_grid</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">((</span><span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">mask_loads</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">H</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">H</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">loads_nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">mask_loads</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">loads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">loads_nodes</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">loads</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">loads_nodes</span>
</span></span><span class="line"><span class="cl">    <span class="n">loads</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span>
</span></span><span class="line"><span class="cl">    <span class="n">BC</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span>
</span></span></code></pre></div><p>con esta función se definen las variables necesarias para hacer análisis de elementos finitos</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">length</span> <span class="o">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">nx</span> <span class="o">=</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="n">ny</span><span class="o">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span> <span class="o">=</span> <span class="n">beam_2</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="n">ny</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elsI</span><span class="p">,</span><span class="n">nodesI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">els</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">IBC</span><span class="p">,</span> <span class="n">UG</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">UCI</span><span class="p">,</span> <span class="n">E_nodesI</span><span class="p">,</span> <span class="n">S_nodesI</span> <span class="o">=</span> <span class="n">postprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">IBC</span><span class="p">,</span> <span class="n">UG</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="análisis-de-elementos-finitos">Análisis de elementos finitos<a hidden class="anchor" aria-hidden="true" href="#análisis-de-elementos-finitos">#</a></h3>
<p>Con estas variables ya podemos resolver el problema y obtener los desplazamientos, deformaciones y tensiones. Para calcular el análisis de elementos finitos se utiliza la biblioteca <a href="https://github.com/AppliedMechanics-EAFIT/SolidsPy">Solidspy 1.0.16</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">preprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Compute IBC matrix and the static solve.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    mats : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models materials
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    loads : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models loads
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    bc_array : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Boundary conditions array
</span></span></span><span class="line"><span class="cl"><span class="s2">    disp : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Static displacement solve
</span></span></span><span class="line"><span class="cl"><span class="s2">    rh_vec : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Vector of loads
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">assem_op</span><span class="p">,</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">neq</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">DME</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">els</span><span class="p">,</span> <span class="n">ndof_el_max</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Number of elements: </span><span class="si">{}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># System assembly</span>
</span></span><span class="line"><span class="cl">    <span class="n">stiff_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">assembler</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">neq</span><span class="p">,</span> <span class="n">assem_op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">rhs_vec</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">loadasem</span><span class="p">(</span><span class="n">loads</span><span class="p">,</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">neq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># System solution</span>
</span></span><span class="line"><span class="cl">    <span class="n">disp</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">static_sol</span><span class="p">(</span><span class="n">stiff_mat</span><span class="p">,</span> <span class="n">rhs_vec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span><span class="o">/</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">rhs_vec</span><span class="o">/</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;The system is not in equilibrium!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">disp</span><span class="p">,</span> <span class="n">rhs_vec</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">postprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">disp</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Compute the nodes displacements, strains and stresses.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    mats : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models materials
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    bc_array : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Boundary conditions array
</span></span></span><span class="line"><span class="cl"><span class="s2">    disp : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Static solve
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    disp_complete : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Displacements at elements.
</span></span></span><span class="line"><span class="cl"><span class="s2">    strain_nodes : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Strains at elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    stress_nodes : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Stresses at elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">disp_complete</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">complete_disp</span><span class="p">(</span><span class="n">bc_array</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">disp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">strain_nodes</span><span class="p">,</span> <span class="n">stress_nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="n">strain_nodes</span><span class="p">,</span> <span class="n">stress_nodes</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">strain_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">disp_complete</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">disp_complete</span><span class="p">,</span> <span class="n">strain_nodes</span><span class="p">,</span> <span class="n">stress_nodes</span>
</span></span></code></pre></div><h3 id="optimización">Optimización<a hidden class="anchor" aria-hidden="true" href="#optimización">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">is_equilibrium</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Check if the system is in equilibrium
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Get from: https://github.com/AppliedMechanics-EAFIT/SolidsPy/blob/master/solidspy/solids_GUI.py
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    mats : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models materials
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    loads : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models loads
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    equil : bool
</span></span></span><span class="line"><span class="cl"><span class="s2">        Variable True when the system is in equilibrium and False when it doesn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">equil</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">    <span class="n">assem_op</span><span class="p">,</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">neq</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">DME</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">els</span><span class="p">,</span> <span class="n">ndof_el_max</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">stiff_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">assembler</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">neq</span><span class="p">,</span> <span class="n">assem_op</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">rhs_vec</span> <span class="o">=</span> <span class="n">ass</span><span class="o">.</span><span class="n">loadasem</span><span class="p">(</span><span class="n">loads</span><span class="p">,</span> <span class="n">bc_array</span><span class="p">,</span> <span class="n">neq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">disp</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">static_sol</span><span class="p">(</span><span class="n">stiff_mat</span><span class="p">,</span> <span class="n">rhs_vec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span><span class="o">/</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">rhs_vec</span><span class="o">/</span><span class="n">stiff_mat</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
</span></span><span class="line"><span class="cl">        <span class="n">equil</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">equil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">protect_els</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">nels</span><span class="p">,</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Compute an mask array with the elements that don&#39;t must be deleted.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    nels : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    loads : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models loads
</span></span></span><span class="line"><span class="cl"><span class="s2">    BC : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Boundary conditions nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    mask_els : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with the elements that don&#39;t must be deleted.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">mask_els</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">protect_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">loads</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">BC</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">protect_index</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">protect_nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">protect_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">els</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">mask_els</span><span class="p">[</span><span class="n">els</span><span class="p">[</span><span class="n">protect_index</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">mask_els</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">del_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Retricts nodes dof that aren&#39;t been used and free up the nodes that are in use.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    loads : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models loads
</span></span></span><span class="line"><span class="cl"><span class="s2">    BC : ndarray 
</span></span></span><span class="line"><span class="cl"><span class="s2">        Boundary conditions nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">protect_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">loads</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">BC</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">els</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">nodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">protect_nodes</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">els</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">nodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Volume calculation.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements.
</span></span></span><span class="line"><span class="cl"><span class="s2">    length : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Length of the beam.
</span></span></span><span class="line"><span class="cl"><span class="s2">    height : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Height of the beam.
</span></span></span><span class="line"><span class="cl"><span class="s2">    nx : float
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of elements in x direction.
</span></span></span><span class="line"><span class="cl"><span class="s2">    ny : float
</span></span></span><span class="line"><span class="cl"><span class="s2">        Number of elements in y direction.
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Return 
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    V: float
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dy</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">nx</span>
</span></span><span class="line"><span class="cl">    <span class="n">dx</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="n">ny</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">V</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sensitivity_els</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">UC</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Calculate the sensitivity number for each element.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    mats : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models materials
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    mask : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Mask of optimal estructure
</span></span></span><span class="line"><span class="cl"><span class="s2">    UC : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Displacements at nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    sensi_number : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Sensitivity number for each element.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>   
</span></span><span class="line"><span class="cl">    <span class="n">sensi_number</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">sensi_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mats</span><span class="p">[</span><span class="n">els</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:])</span>
</span></span><span class="line"><span class="cl">        <span class="n">elcoor</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">els</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:],</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">kloc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">uel</span><span class="o">.</span><span class="n">elast_quad4</span><span class="p">(</span><span class="n">elcoor</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">node_el</span> <span class="o">=</span> <span class="n">els</span><span class="p">[</span><span class="n">el</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="n">U_el</span> <span class="o">=</span> <span class="n">UC</span><span class="p">[</span><span class="n">node_el</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">U_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">U_el</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">a_i</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">U_el</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kloc</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U_el</span><span class="p">))[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">sensi_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sensi_number</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_number</span> <span class="o">=</span> <span class="n">sensi_number</span><span class="o">/</span><span class="n">sensi_number</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sensi_number</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">adjacency_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Create an adjacency matrix for the elements connected to each node.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes.
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements.
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    adj_nodes : ndarray, nodes.shape[0]
</span></span></span><span class="line"><span class="cl"><span class="s2">        Adjacency elements for each node.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">adj_nodes</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="n">adj_els</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">els</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">adj_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adj_els</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">adj_nodes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">center_els</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Calculate the center of each element.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes.
</span></span></span><span class="line"><span class="cl"><span class="s2">    els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models elements.
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    centers : ndarray, nodes.shape[0]
</span></span></span><span class="line"><span class="cl"><span class="s2">        Adjacency elements for each node.
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">els</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">el</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:],</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">centers</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sensitivity_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">adj_nodes</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">sensi_els</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Calculate the sensitivity of each node.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    adj_nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Adjacency matrix of nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    centers : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with center of elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    sensi_els : ndarra
</span></span></span><span class="line"><span class="cl"><span class="s2">        Sensitivity of each element without filter
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    sensi_nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Sensitivity of each nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_nodes</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connected_els</span> <span class="o">=</span> <span class="n">adj_nodes</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">connected_els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">delta</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">connected_els</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">r_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># We can remove this line and just use a constant because the distance is always the same</span>
</span></span><span class="line"><span class="cl">            <span class="n">w_i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">connected_els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r_ij</span><span class="o">/</span><span class="n">r_ij</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="n">sensi</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_i</span> <span class="o">*</span> <span class="n">sensi_els</span><span class="p">[</span><span class="n">connected_els</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">sensi</span> <span class="o">=</span> <span class="n">sensi_els</span><span class="p">[</span><span class="n">connected_els</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">        <span class="n">sensi_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sensi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sensi_nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sensi_nodes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sensitivity_filter</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">sensi_nodes</span><span class="p">,</span> <span class="n">r_min</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Performe the sensitivity filter.
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Parameters
</span></span></span><span class="line"><span class="cl"><span class="s2">    ----------
</span></span></span><span class="line"><span class="cl"><span class="s2">    nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with models nodes
</span></span></span><span class="line"><span class="cl"><span class="s2">    sensi_nodes : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with nodal sensitivity
</span></span></span><span class="line"><span class="cl"><span class="s2">    centers : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Array with center of elements
</span></span></span><span class="line"><span class="cl"><span class="s2">    r_min : ndarra
</span></span></span><span class="line"><span class="cl"><span class="s2">        Minimum distance 
</span></span></span><span class="line"><span class="cl"><span class="s2">        
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns
</span></span></span><span class="line"><span class="cl"><span class="s2">    -------
</span></span></span><span class="line"><span class="cl"><span class="s2">    sensi_els : ndarray
</span></span></span><span class="line"><span class="cl"><span class="s2">        Sensitivity of each element with filter
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_els</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">delta</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">c</span>
</span></span><span class="line"><span class="cl">        <span class="n">r_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">omega_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_ij</span> <span class="o">&lt;</span> <span class="n">r_min</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">omega_i</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r_ij</span><span class="p">[</span><span class="n">omega_i</span><span class="p">]</span><span class="o">/</span><span class="n">r_ij</span><span class="p">[</span><span class="n">omega_i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="n">sensi_els</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">w</span><span class="o">*</span><span class="n">sensi_nodes</span><span class="p">[</span><span class="n">omega_i</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="n">sensi_els</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sensi_els</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_els</span> <span class="o">=</span> <span class="n">sensi_els</span><span class="o">/</span><span class="n">sensi_els</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sensi_els</span>
</span></span></code></pre></div><p>Primero definamos el número de iteraciones <code>nitro</code>, <code>ERR</code> la relación de rechazo evolutivo y <code>t</code> la tolerancia de convergencia permitida, el radio mínimo <code>r_min</code> y el volumen óptimo <code>V_opt</code>. Después de definir estas variables, calculamos la matriz de adyacencia para los nodos <code>adjacency_nodes()</code> y el centro de cada elemento <code>center_els()</code>, estas matrices se utilizarán para lograr el esquema de filtro.</p>
<p>La secuencia del bucle se define con:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">niter</span> <span class="o">=</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="n">ERR</span> <span class="o">=</span> <span class="mf">0.005</span>
</span></span><span class="line"><span class="cl"><span class="n">t</span> <span class="o">=</span> <span class="mf">0.01</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1.5</span>
</span></span><span class="line"><span class="cl"><span class="n">adj_nodes</span> <span class="o">=</span> <span class="n">adjacency_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">centers</span> <span class="o">=</span> <span class="n">center_els</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Vi</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">els</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">V_opt</span> <span class="o">=</span> <span class="n">Vi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.50</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Initialize variables.</span>
</span></span><span class="line"><span class="cl"><span class="n">ELS</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">sensi_I</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl"><span class="n">C_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">niter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">error</span> <span class="o">=</span> <span class="mi">1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Calculate the optimal design array elements</span>
</span></span><span class="line"><span class="cl">    <span class="n">els_del</span> <span class="o">=</span> <span class="n">els</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span> <span class="o">=</span> <span class="n">Vi</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check equilibrium</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_equilibrium</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els_del</span><span class="p">,</span> <span class="n">loads</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Is not equilibrium&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Storage the solution</span>
</span></span><span class="line"><span class="cl">    <span class="n">ELS</span> <span class="o">=</span> <span class="n">els_del</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># FEW analysis</span>
</span></span><span class="line"><span class="cl">    <span class="n">IBC</span><span class="p">,</span> <span class="n">UG</span><span class="p">,</span> <span class="n">rhs_vec</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els_del</span><span class="p">,</span> <span class="n">loads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">UC</span><span class="p">,</span> <span class="n">E_nodes</span><span class="p">,</span> <span class="n">S_nodes</span> <span class="o">=</span> <span class="n">postprocessing</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els_del</span><span class="p">,</span> <span class="n">IBC</span><span class="p">,</span> <span class="n">UG</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Sensitivity filter</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_e</span> <span class="o">=</span> <span class="n">sensitivity_els</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">els</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">UC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_nodes</span> <span class="o">=</span> <span class="n">sensitivity_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">adj_nodes</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">sensi_e</span><span class="p">)</span> <span class="c1">#3.4</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_number</span> <span class="o">=</span> <span class="n">sensitivity_filter</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">sensi_nodes</span><span class="p">,</span> <span class="n">r_min</span><span class="p">)</span> <span class="c1">#3.6</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Avarage the sensitivity numbers to the historical information </span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">        <span class="n">sensi_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">sensi_number</span> <span class="o">+</span> <span class="n">sensi_I</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># 3.8</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_number</span> <span class="o">=</span> <span class="n">sensi_number</span><span class="o">/</span><span class="n">sensi_number</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the optimal volume is reached and calculate the next volume</span>
</span></span><span class="line"><span class="cl">    <span class="n">V_r</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;=</span> <span class="n">V_opt</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">els_k</span> <span class="o">=</span> <span class="n">els_del</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">V_r</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">V_k</span> <span class="o">=</span> <span class="n">V</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ERR</span><span class="p">)</span> <span class="k">if</span> <span class="n">V</span> <span class="o">&lt;</span> <span class="n">V_opt</span> <span class="k">else</span> <span class="n">V</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ERR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Remove/add threshold</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sensi_number</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">els_k</span> <span class="o">=</span> <span class="n">els_del</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V_k</span><span class="o">/</span><span class="n">V</span>
</span></span><span class="line"><span class="cl">    <span class="n">alpha_del</span> <span class="o">=</span> <span class="n">sensi_sort</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">els_k</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Remove/add elements</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask</span> <span class="o">=</span> <span class="n">sensi_number</span> <span class="o">&gt;</span> <span class="n">alpha_del</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask_els</span> <span class="o">=</span> <span class="n">protect_els</span><span class="p">(</span><span class="n">els</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">mask</span><span class="p">)],</span> <span class="n">els</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask_els</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">del_node</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">els</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">loads</span><span class="p">,</span> <span class="n">BC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Calculate the strain energy and storage it </span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">rhs_vec</span><span class="o">.</span><span class="n">T</span><span class="nd">@UG</span>
</span></span><span class="line"><span class="cl">    <span class="n">C_h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span> <span class="n">error</span> <span class="o">=</span> <span class="n">C_h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">C_h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">C_h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check for convergence</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">error</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="ow">and</span> <span class="n">V_r</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;convergence&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Save the sensitvity number for the next iteration</span>
</span></span><span class="line"><span class="cl">    <span class="n">sensi_I</span> <span class="o">=</span> <span class="n">sensi_number</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span></span></code></pre></div><h1 id="resultados">Resultados<a hidden class="anchor" aria-hidden="true" href="#resultados">#</a></h1>
<p>Como se puede apreciar en la <em>figura 2</em> se presentan los resultados del ejercicio propuesto al inicio del post, para el gráfico <em>2.a</em> se evidencia que el método converge a una estructura óptima. En este programa BESO, la dependencia de la malla y los problemas del patrón de tablero de ajedrez se consideran bajo el esquema de filtro <em>2.d</em>.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img loading="lazy" src="/BESO.png" alt="Scenario 1: Across columns"  />
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><!-- raw HTML omitted -->Figura 2. Topologías BESO para vigas en voladizo con diferente fracción de volumen: (a) 80%; (b) 70%; c) 60 %; (d) 50%.<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h1 id="referencias">Referencias<a hidden class="anchor" aria-hidden="true" href="#referencias">#</a></h1>
<p>[1] Nabaki, K., Shen, J. y Huang, X. (2019). Optimización topológica evolutiva de estructuras continuas considerando falla por fatiga. <em>Materiales y diseño</em>, <em>166</em>, 107586. doi:10.1016/j.matdes.2019.107586</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://kssgarcia.github.io/es/">Kssgarcia</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>
</html>
